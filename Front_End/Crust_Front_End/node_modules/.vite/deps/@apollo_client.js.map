{
  "version": 3,
  "sources": ["../../../../node_modules/rehackt/index.js", "../../../../node_modules/@apollo/src/link/http/iterators/async.ts", "../../../../node_modules/@apollo/src/link/http/iterators/nodeStream.ts", "../../../../node_modules/@apollo/src/link/http/iterators/promise.ts", "../../../../node_modules/@apollo/src/link/http/iterators/reader.ts", "../../../../node_modules/@apollo/src/link/http/responseIterator.ts", "../../../../node_modules/@apollo/src/link/http/parseAndCheckHttpResponse.ts", "../../../../node_modules/@apollo/src/link/http/serializeFetchParameter.ts", "../../../../node_modules/@apollo/src/link/http/selectHttpOptionsAndBody.ts", "../../../../node_modules/@apollo/src/link/http/checkFetcher.ts", "../../../../node_modules/@apollo/src/link/http/createSignalIfSupported.ts", "../../../../node_modules/@apollo/src/link/http/selectURI.ts", "../../../../node_modules/@apollo/src/link/http/rewriteURIForGET.ts", "../../../../node_modules/@apollo/src/link/http/createHttpLink.ts", "../../../../node_modules/@apollo/src/link/http/HttpLink.ts", "../../../../node_modules/@apollo/src/core/LocalState.ts", "../../../../node_modules/@apollo/src/core/ApolloClient.ts", "../../../../node_modules/graphql-tag/src/index.ts", "../../../../node_modules/@apollo/src/core/index.ts", "../../../../node_modules/@apollo/src/react/context/ApolloConsumer.tsx", "../../../../node_modules/@apollo/src/react/context/ApolloContext.ts", "../../../../node_modules/@apollo/src/react/context/ApolloProvider.tsx", "../../../../node_modules/@apollo/src/react/hooks/useApolloClient.ts", "../../../../node_modules/@apollo/src/react/hooks/useLazyQuery.ts", "../../../../node_modules/@apollo/src/react/hooks/useQuery.ts", "../../../../node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts", "../../../../node_modules/@apollo/src/react/parser/index.ts", "../../../../node_modules/@apollo/src/react/hooks/internal/useDeepMemo.ts", "../../../../node_modules/@apollo/src/react/hooks/internal/useIsomorphicLayoutEffect.ts", "../../../../node_modules/@apollo/src/react/hooks/internal/useRenderGuard.ts", "../../../../node_modules/@apollo/src/react/hooks/internal/__use.ts", "../../../../node_modules/@apollo/src/react/hooks/internal/wrapHook.ts", "../../../../node_modules/@apollo/src/react/hooks/useMutation.ts", "../../../../node_modules/@apollo/src/react/hooks/useSubscription.ts", "../../../../node_modules/@apollo/src/react/hooks/useReactiveVar.ts", "../../../../node_modules/@apollo/src/react/hooks/useFragment.ts", "../../../../node_modules/@apollo/src/react/hooks/useSuspenseQuery.ts", "../../../../node_modules/@apollo/src/react/internal/cache/QueryReference.ts", "../../../../node_modules/@apollo/src/react/internal/cache/SuspenseCache.ts", "../../../../node_modules/@apollo/src/react/internal/cache/getSuspenseCache.ts", "../../../../node_modules/@apollo/src/react/hooks/constants.ts", "../../../../node_modules/@apollo/src/react/hooks/useBackgroundQuery.ts", "../../../../node_modules/@apollo/src/react/hooks/useLoadableQuery.ts", "../../../../node_modules/@apollo/src/react/hooks/useQueryRefHandlers.ts", "../../../../node_modules/@apollo/src/react/hooks/useReadQuery.ts", "../../../../node_modules/@apollo/src/react/query-preloader/createQueryPreloader.ts"],
  "sourcesContent": ["\"use strict\";\r\nif (0) {\r\n  // Trick cjs-module-lexer into adding named exports for all React exports.\r\n  // (if imported with `import()`, they will appear in `.default` as well.)\r\n  // This way, cjs-module-lexer will let all of react's (named) exports through unchanged.\r\n  module.exports = require(\"react\");\r\n}\r\n// We don't want bundlers to error when they encounter usage of any of these exports.\r\n// It's up to the package author to ensure that if they access React internals,\r\n// they do so in a safe way that won't break if React changes how they use these internals.\r\n// (e.g. only access them in development, and only in an optional way that won't\r\n// break if internals are not there or do not have the expected structure)\r\n// @ts-ignore\r\nmodule.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = undefined;\r\n// @ts-ignore\r\nmodule.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = undefined;\r\n// @ts-ignore\r\nmodule.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = undefined;\r\n// Here we actually pull in the React library and add everything\r\n// it exports to our own `module.exports`.\r\n// If React suddenly were to add one of the above \"polyfilled\" exports,\r\n// the React version would overwrite our version, so this should be\r\n// future-proof.\r\nObject.assign(module.exports, require(\"react\"));\r\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<IteratorResult<T, T | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read() as Promise<\n        | ReadableStreamReadValueResult<T>\n        // DoneResult has `value` optional, which doesn't comply with an\n        // `IteratorResult`, so we assert it to `T | undefined` instead\n        | Required<ReadableStreamReadDoneResult<T | undefined>>\n      >;\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<\n      T,\n      T | undefined\n    > {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n", "import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              if (Object.keys(result).length === 1 && result.payload === null) {\n                return;\n              }\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e: any) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders: Record<string, string> = {};\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData: Record<string, { originalName: string; value: string }> =\n    {};\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders: Record<string, string> = {};\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\n\nexport const checkFetcher = (fetcher: typeof fetch | undefined) => {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(`\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `);\n  }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === \"undefined\")\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n", "import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type { DefinitionNode } from \"graphql\";\n\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport {\n  handleError,\n  readMultipartBody,\n  parseAndCheckHttpResponse,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport {\n  selectHttpOptionsAndBodyInternal,\n  defaultPrinter,\n  fallbackHttpConfig,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport {\n  maybe,\n  getMainDefinition,\n  removeClientSetsFromDocument,\n} from \"../../utilities/index.js\";\n\nconst backupFetch = maybe(() => fetch);\n\nexport const createHttpLink = (linkOptions: HttpOptions = {}) => {\n  let {\n    uri = \"/graphql\",\n    // use default global fetch if nothing passed in\n    fetch: preferredFetch,\n    print = defaultPrinter,\n    includeExtensions,\n    preserveHeaderCase,\n    useGETForQueries,\n    includeUnusedVariables = false,\n    ...requestOptions\n  } = linkOptions;\n\n  if (__DEV__) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n\n  const linkConfig = {\n    http: { includeExtensions, preserveHeaderCase },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders: {\n      \"apollographql-client-name\"?: string;\n      \"apollographql-client-version\"?: string;\n    } = {};\n\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    if (hasDirectives([\"client\"], operation.query)) {\n      const transformedQuery = removeClientSetsFromDocument(operation.query);\n\n      if (!transformedQuery) {\n        return fromError(\n          new Error(\n            \"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"\n          )\n        );\n      }\n\n      operation.query = transformedQuery;\n    }\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBodyInternal(\n      operation,\n      print,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig\n    );\n\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(\n        body.variables,\n        operation.query\n      );\n    }\n\n    let controller: AbortController | undefined;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    const definitionIsSubscription = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    const isSubscription = definitionIsSubscription(\n      getMainDefinition(operation.query)\n    );\n    // does not match custom directives beginning with @defer\n    const hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = \"GET\";\n    }\n\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      let acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        invariant.warn(\"Multipart-subscriptions do not support @defer\");\n      }\n\n      if (isSubscription) {\n        acceptHeader +=\n          \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n\n    if (options.method === \"GET\") {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable((observer) => {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;\n\n      const observerNext = observer.next.bind(observer);\n      currentFetch!(chosenURI, options)\n        .then((response) => {\n          operation.setContext({ response });\n          const ctype = response.headers?.get(\"content-type\");\n\n          if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n            return readMultipartBody(response, observerNext);\n          } else {\n            return parseAndCheckHttpResponse(operation)(response).then(\n              observerNext\n            );\n          }\n        })\n        .then(() => {\n          controller = undefined;\n          observer.complete();\n        })\n        .catch((err) => {\n          controller = undefined;\n          handleError(err, observer);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n", "import { ApolloLink } from \"../core/index.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\n\nexport class HttpLink extends ApolloLink {\n  constructor(public options: HttpOptions = {}) {\n    super(createHttpLink(options).request);\n  }\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode, FormattedExecutionResult } from \"graphql\";\n\nimport type { FetchResult, GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform, Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nexport interface DevtoolsOptions {\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n   *\n   * The default value is `false` in production and `true` in development if there is a `window` object.\n   */\n  enabled?: boolean;\n\n  /**\n   * Optional name for this `ApolloClient` instance in the devtools. This is\n   * useful when you instantiate multiple clients and want to be able to\n   * identify them by name.\n   */\n  name?: string;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  uri?: string | UriFunction;\n  credentials?: string;\n  /**\n   * An object representing headers to include in every HTTP request, such as `{Authorization: 'Bearer 1234'}`\n   *\n   * This value will be ignored when using the `link` option.\n   */\n  headers?: Record<string, string>;\n  /**\n   * You can provide an `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   * @deprecated Please use the `devtools.enabled` option.\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  defaultContext?: Partial<DefaultContext>;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   */\n  version?: string;\n  documentTransform?: DocumentTransform;\n\n  /**\n   * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n   *\n   * @since 3.11.0\n   */\n  devtools?: DevtoolsOptions;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/core/cache.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n  public readonly devtoolsConfig: DevtoolsOptions;\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n      devtools,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled || connectToDevTools,\n    };\n\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = __DEV__;\n    }\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient<any>): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient<any>;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: QueryOptions<TVariables, T>): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<FetchResult<TData>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: SubscriptionOptions<TVariables, T>): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TFragmentData = unknown,\n    TVariables = OperationVariables,\n  >(\n    options: WatchFragmentOptions<TFragmentData, TVariables>\n  ): Observable<WatchFragmentResult<TFragmentData>> {\n    return this.cache.watchFragment<TFragmentData, TVariables>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    payload: GraphQLRequest\n  ): Observable<FormattedExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   * ```ts\n   * console.log(client.getMemoryInternals())\n   * ```\n   * Logs output in the following JSON format:\n   * @example\n   * ```json\n   *{\n   *  limits:     {\n   *    parser: 1000,\n   *    canonicalStringify: 1000,\n   *    print: 2000,\n   *    'documentTransform.cache': 2000,\n   *    'queryManager.getDocumentInfo': 2000,\n   *    'PersistedQueryLink.persistedQueryHashes': 2000,\n   *    'fragmentRegistry.transform': 2000,\n   *    'fragmentRegistry.lookup': 1000,\n   *    'fragmentRegistry.findFragmentSpreads': 4000,\n   *    'cache.fragmentQueryDocuments': 1000,\n   *    'removeTypenameFromVariables.getVariableDefinitions': 2000,\n   *    'inMemoryCache.maybeBroadcastWatch': 5000,\n   *    'inMemoryCache.executeSelectionSet': 10000,\n   *    'inMemoryCache.executeSubSelectedArray': 5000\n   *  },\n   *  sizes: {\n   *    parser: 26,\n   *    canonicalStringify: 4,\n   *    print: 14,\n   *    addTypenameDocumentTransform: [\n   *      {\n   *        cache: 14,\n   *      },\n   *    ],\n   *    queryManager: {\n   *      getDocumentInfo: 14,\n   *      documentTransforms: [\n   *        {\n   *          cache: 14,\n   *        },\n   *        {\n   *          cache: 14,\n   *        },\n   *      ],\n   *    },\n   *    fragmentRegistry: {\n   *      findFragmentSpreads: 34,\n   *      lookup: 20,\n   *      transform: 14,\n   *    },\n   *    cache: {\n   *      fragmentQueryDocuments: 22,\n   *    },\n   *    inMemoryCache: {\n   *      executeSelectionSet: 4345,\n   *      executeSubSelectedArray: 1206,\n   *      maybeBroadcastWatch: 32,\n   *    },\n   *    links: [\n   *      {\n   *        PersistedQueryLink: {\n   *          persistedQueryHashes: 14,\n   *        },\n   *      },\n   *      {\n   *        removeTypenameFromVariables: {\n   *          getVariableDefinitions: 14,\n   *        },\n   *      },\n   *    ],\n   *  },\n   * }\n   *```\n   */\n  public getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n", "import { parse } from 'graphql';\r\n\r\nimport {\r\n  DocumentNode,\r\n  DefinitionNode,\r\n  Location,\r\n} from 'graphql/language/ast';\r\n\r\n// A map docString -> graphql document\r\nconst docCache = new Map<string, DocumentNode>();\r\n\r\n// A map fragmentName -> [normalized source]\r\nconst fragmentSourceMap = new Map<string, Set<string>>();\r\n\r\nlet printFragmentWarnings = true;\r\nlet experimentalFragmentVariables = false;\r\n\r\n// Strip insignificant whitespace\r\n// Note that this could do a lot more, such as reorder fields etc.\r\nfunction normalize(string: string) {\r\n  return string.replace(/[\\s,]+/g, ' ').trim();\r\n}\r\n\r\nfunction cacheKeyFromLoc(loc: Location) {\r\n  return normalize(loc.source.body.substring(loc.start, loc.end));\r\n}\r\n\r\n// Take a unstripped parsed document (query/mutation or even fragment), and\r\n// check all fragment definitions, checking for name->source uniqueness.\r\n// We also want to make sure only unique fragments exist in the document.\r\nfunction processFragments(ast: DocumentNode) {\r\n  const seenKeys = new Set<string>();\r\n  const definitions: DefinitionNode[] = [];\r\n\r\n  ast.definitions.forEach(fragmentDefinition => {\r\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\r\n      var fragmentName = fragmentDefinition.name.value;\r\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\r\n\r\n      // We know something about this fragment\r\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\r\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\r\n        // this is a problem because the app developer is trying to register another fragment with\r\n        // the same name as one previously registered. So, we tell them about it.\r\n        if (printFragmentWarnings) {\r\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\r\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\r\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\r\n        }\r\n      } else if (!sourceKeySet) {\r\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\r\n      }\r\n\r\n      sourceKeySet.add(sourceKey);\r\n\r\n      if (!seenKeys.has(sourceKey)) {\r\n        seenKeys.add(sourceKey);\r\n        definitions.push(fragmentDefinition);\r\n      }\r\n    } else {\r\n      definitions.push(fragmentDefinition);\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...ast,\r\n    definitions,\r\n  };\r\n}\r\n\r\nfunction stripLoc(doc: DocumentNode) {\r\n  const workSet = new Set<Record<string, any>>(doc.definitions);\r\n\r\n  workSet.forEach(node => {\r\n    if (node.loc) delete node.loc;\r\n    Object.keys(node).forEach(key => {\r\n      const value = node[key];\r\n      if (value && typeof value === 'object') {\r\n        workSet.add(value);\r\n      }\r\n    });\r\n  });\r\n\r\n  const loc = doc.loc as Record<string, any>;\r\n  if (loc) {\r\n    delete loc.startToken;\r\n    delete loc.endToken;\r\n  }\r\n\r\n  return doc;\r\n}\r\n\r\nfunction parseDocument(source: string) {\r\n  var cacheKey = normalize(source);\r\n  if (!docCache.has(cacheKey)) {\r\n    const parsed = parse(source, {\r\n      experimentalFragmentVariables,\r\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\r\n    } as any);\r\n    if (!parsed || parsed.kind !== 'Document') {\r\n      throw new Error('Not a valid GraphQL document.');\r\n    }\r\n    docCache.set(\r\n      cacheKey,\r\n      // check that all \"new\" fragments inside the documents are consistent with\r\n      // existing fragments of the same name\r\n      stripLoc(processFragments(parsed)),\r\n    );\r\n  }\r\n  return docCache.get(cacheKey)!;\r\n}\r\n\r\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\r\nexport function gql(\r\n  literals: string | readonly string[],\r\n  ...args: any[]\r\n) {\r\n\r\n  if (typeof literals === 'string') {\r\n    literals = [literals];\r\n  }\r\n\r\n  let result = literals[0];\r\n\r\n  args.forEach((arg, i) => {\r\n    if (arg && arg.kind === 'Document') {\r\n      result += arg.loc.source.body;\r\n    } else {\r\n      result += arg;\r\n    }\r\n    result += literals[i + 1];\r\n  });\r\n\r\n  return parseDocument(result);\r\n}\r\n\r\nexport function resetCaches() {\r\n  docCache.clear();\r\n  fragmentSourceMap.clear();\r\n}\r\n\r\nexport function disableFragmentWarnings() {\r\n  printFragmentWarnings = false;\r\n}\r\n\r\nexport function enableExperimentalFragmentVariables() {\r\n  experimentalFragmentVariables = true;\r\n}\r\n\r\nexport function disableExperimentalFragmentVariables() {\r\n  experimentalFragmentVariables = false;\r\n}\r\n\r\nconst extras = {\r\n  gql,\r\n  resetCaches,\r\n  disableFragmentWarnings,\r\n  enableExperimentalFragmentVariables,\r\n  disableExperimentalFragmentVariables,\r\n};\r\n\r\nexport namespace gql {\r\n  export const {\r\n    gql,\r\n    resetCaches,\r\n    disableFragmentWarnings,\r\n    enableExperimentalFragmentVariables,\r\n    disableExperimentalFragmentVariables,\r\n  } = extras;\r\n}\r\n\r\ngql.default = gql;\r\n\r\nexport default gql;\r\n", "/* Core */\n\nexport type { ApolloClientOptions, DefaultOptions } from \"./ApolloClient.js\";\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport type {\n  FetchMoreOptions,\n  UpdateQueryOptions,\n} from \"./ObservableQuery.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  FetchPolicy,\n  WatchQueryFetchPolicy,\n  MutationFetchPolicy,\n  RefetchWritePolicy,\n  ErrorPolicy,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n} from \"./watchQueryOptions.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport * from \"./types.js\";\nexport type { Resolver, FragmentMatcher } from \"./LocalState.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\n/* Cache */\n\nexport type {\n  // All the exports (types) from ../cache, minus cacheSlot,\n  // which we want to keep semi-private.\n  Transaction,\n  DataProxy,\n  InMemoryCacheConfig,\n  ReactiveVar,\n  TypePolicies,\n  TypePolicy,\n  FieldPolicy,\n  FieldReadFunction,\n  FieldMergeFunction,\n  FieldFunctionOptions,\n  PossibleTypesMap,\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/index.js\";\nexport {\n  Cache,\n  ApolloCache,\n  InMemoryCache,\n  MissingFieldError,\n  defaultDataIdFromObject,\n  makeVar,\n} from \"../cache/index.js\";\n\nexport * from \"../cache/inmemory/types.js\";\n\n/* Link */\n\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport type { ServerError } from \"../link/utils/index.js\";\nexport {\n  fromError,\n  toPromise,\n  fromPromise,\n  throwServerError,\n} from \"../link/utils/index.js\";\n\n/* Utilities */\n\nexport type {\n  DocumentTransformCacheKey,\n  Observer,\n  ObservableSubscription,\n  Reference,\n  StoreObject,\n} from \"../utilities/index.js\";\nexport {\n  DocumentTransform,\n  Observable,\n  isReference,\n  makeReference,\n} from \"../utilities/index.js\";\n\n/* Supporting */\n\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(__DEV__ ? \"log\" : \"silent\");\n\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n} from \"graphql-tag\";\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport type * as ReactTypes from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<object>) => ReactTypes.ReactNode;\n}\n\nexport const ApolloConsumer: ReactTypes.FC<ApolloConsumerProps> = (props) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any) => {\n        invariant(\n          context && context.client,\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n            \"Wrap the root component in an <ApolloProvider>.\"\n        );\n        return props.children(context.client);\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import * as React from \"rehackt\";\nimport type * as ReactTypes from \"react\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { canUseSymbol } from \"../../utilities/index.js\";\nimport type { RenderPromises } from \"../ssr/index.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: RenderPromises;\n}\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nconst contextKey =\n  canUseSymbol ? Symbol.for(\"__APOLLO_CONTEXT__\") : \"__APOLLO_CONTEXT__\";\n\nexport function getApolloContext(): ReactTypes.Context<ApolloContextValue> {\n  invariant(\n    \"createContext\" in React,\n    \"Invoking `getApolloContext` in an environment where `React.createContext` is not available.\\n\" +\n      \"The Apollo Client functionality you are trying to use is only available in React Client Components.\\n\" +\n      'Please make sure to add \"use client\" at the top of your file.\\n' +\n      // TODO: change to React documentation once React documentation contains information about Client Components\n      \"For more information, see https://nextjs.org/docs/getting-started/react-essentials#client-components\"\n  );\n\n  let context = (React.createContext as any)[\n    contextKey\n  ] as React.Context<ApolloContextValue>;\n  if (!context) {\n    Object.defineProperty(React.createContext, contextKey, {\n      value: (context = React.createContext<ApolloContextValue>({})),\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n    context.displayName = \"ApolloContext\";\n  }\n  return context;\n}\n\n/**\n * @deprecated This function has no \"resetting\" effect since Apollo Client 3.4.12,\n * and will be removed in the next major version of Apollo Client.\n * If you want to get the Apollo Context, use `getApolloContext` instead.\n */\nexport const resetApolloContext = getApolloContext;\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport type * as ReactTypes from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: ReactTypes.ReactNode | ReactTypes.ReactNode[] | null;\n}\n\nexport const ApolloProvider: ReactTypes.FC<ApolloProviderProps<any>> = ({\n  client,\n  children,\n}) => {\n  const ApolloContext = getApolloContext();\n  const parentContext = React.useContext(ApolloContext);\n\n  const context = React.useMemo(() => {\n    return {\n      ...parentContext,\n      client: client || parentContext.client,\n    };\n  }, [parentContext, client]);\n\n  invariant(\n    context.client,\n    \"ApolloProvider was not passed a client instance. Make \" +\n      'sure you pass in your client via the \"client\" prop.'\n  );\n\n  return (\n    <ApolloContext.Provider value={context}>{children}</ApolloContext.Provider>\n  );\n};\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\n\n/**\n * @example\n * ```jsx\n * import { useApolloClient } from '@apollo/client';\n *\n * function SomeComponent() {\n *   const client = useApolloClient();\n *   // `client` is now set to the `ApolloClient` instance being used by the\n *   // application (that was configured using something like `ApolloProvider`)\n * }\n * ```\n *\n * @since 3.0.0\n * @returns The `ApolloClient` instance being used by the application.\n */\nexport function useApolloClient(\n  override?: ApolloClient<object>\n): ApolloClient<object> {\n  const context = React.useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n      \"Wrap the root component in an <ApolloProvider>, or pass an ApolloClient \" +\n      \"instance in via options.\"\n  );\n\n  return client;\n}\n", "import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"rehackt\";\n\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryHookOptions,\n  QueryResult,\n} from \"../types/types.js\";\nimport type { InternalResult, ObsQueryWithMeta } from \"./useQuery.js\";\nimport {\n  createMakeWatchQueryOptions,\n  getDefaultFetchPolicy,\n  getObsQueryOptions,\n  toQueryResult,\n  useQueryInternals,\n} from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"stopPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = options;\n  queryRef.current = document;\n\n  const queryHookOptions = {\n    ...merged,\n    skip: !execOptionsRef.current,\n  };\n  const {\n    obsQueryFields,\n    result: useQueryResult,\n    client,\n    resultData,\n    observable,\n    onQueryExecuted,\n  } = useQueryInternals(document, queryHookOptions);\n\n  const initialFetchPolicy =\n    observable.options.initialFetchPolicy ||\n    getDefaultFetchPolicy(\n      queryHookOptions.defaultOptions,\n      client.defaultOptions\n    );\n\n  const forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = obsQueryFields[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods as typeof obsQueryFields;\n  }, [forceUpdateState, obsQueryFields]);\n\n  const called = !!execOptionsRef.current;\n  const result = React.useMemo(\n    () => ({\n      ...useQueryResult,\n      ...eagerMethods,\n      called,\n    }),\n    [useQueryResult, eagerMethods, called]\n  );\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current =\n        executeOptions ?\n          {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = executeQuery(\n        resultData,\n        observable,\n        client,\n        document,\n        { ...options, skip: false },\n        onQueryExecuted\n      ).then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    [\n      client,\n      document,\n      eagerMethods,\n      initialFetchPolicy,\n      observable,\n      resultData,\n      onQueryExecuted,\n    ]\n  );\n\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n\n  const stableExecute = React.useCallback<typeof execute>(\n    (...args) => executeRef.current(...args),\n    []\n  );\n  return [stableExecute, result];\n}\n\nfunction executeQuery<TData, TVariables extends OperationVariables>(\n  resultData: InternalResult<TData, TVariables>,\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  client: ApolloClient<object>,\n  currentQuery: DocumentNode,\n  options: QueryHookOptions<TData, TVariables> & {\n    query?: DocumentNode;\n  },\n  onQueryExecuted: (options: WatchQueryOptions<TVariables, TData>) => void\n) {\n  const query = options.query || currentQuery;\n  const watchQueryOptions = createMakeWatchQueryOptions(\n    client,\n    query,\n    options,\n    false\n  )(observable);\n\n  const concast = observable.reobserveAsConcast(\n    getObsQueryOptions(observable, client, options, watchQueryOptions)\n  );\n  onQueryExecuted(watchQueryOptions);\n\n  return new Promise<\n    Omit<QueryResult<TData, TVariables>, (typeof EAGER_METHODS)[number]>\n  >((resolve) => {\n    let result: ApolloQueryResult<TData>;\n\n    // Subscribe to the concast independently of the ObservableQuery in case\n    // the component gets unmounted before the promise resolves. This prevents\n    // the concast from terminating early and resolving with `undefined` when\n    // there are no more subscribers for the concast.\n    concast.subscribe({\n      next: (value) => {\n        result = value;\n      },\n      error: () => {\n        resolve(\n          toQueryResult(\n            observable.getCurrentResult(),\n            resultData.previousData,\n            observable,\n            client\n          )\n        );\n      },\n      complete: () => {\n        resolve(\n          toQueryResult(result, resultData.previousData, observable, client)\n        );\n      },\n    });\n  });\n}\n", "/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\nimport { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  ApolloClient,\n  DefaultOptions,\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport type { RenderPromises } from \"../ssr/RenderPromises.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\ntype InternalQueryResult<TData, TVariables extends OperationVariables> = Omit<\n  QueryResult<TData, TVariables>,\n  Exclude<keyof ObservableQueryFields<TData, TVariables>, \"variables\">\n>;\n\nfunction noop() {}\nexport const lastWatchOptions = Symbol();\n\nexport interface ObsQueryWithMeta<TData, TVariables extends OperationVariables>\n  extends ObservableQuery<TData, TVariables> {\n  [lastWatchOptions]?: WatchQueryOptions<TVariables, TData>;\n}\n\nexport interface InternalResult<TData, TVariables extends OperationVariables> {\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  current?: undefined | InternalQueryResult<TData, TVariables>;\n  previousData?: undefined | TData;\n}\n\ninterface InternalState<TData, TVariables extends OperationVariables> {\n  client: ReturnType<typeof useApolloClient>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  observable: ObsQueryWithMeta<TData, TVariables>;\n  resultData: InternalResult<TData, TVariables>;\n}\n\nexport type UpdateInternalState<\n  TData,\n  TVariables extends OperationVariables,\n> = (state: InternalState<TData, TVariables>) => void;\n\ninterface Callbacks<TData> {\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  onCompleted(data: TData): void;\n  onError(error: ApolloError): void;\n}\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return wrapHook(\n    \"useQuery\",\n    _useQuery,\n    useApolloClient(options && options.client)\n  )(query, options);\n}\n\nfunction _useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const { result, obsQueryFields } = useQueryInternals(query, options);\n  return React.useMemo(\n    () => ({ ...result, ...obsQueryFields }),\n    [result, obsQueryFields]\n  );\n}\n\nfunction useInternalState<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient<object>,\n  query: DocumentNode | TypedDocumentNode<any, any>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>,\n  renderPromises: RenderPromises | undefined,\n  makeWatchQueryOptions: () => WatchQueryOptions<TVariables, TData>\n) {\n  function createInternalState(previous?: InternalState<TData, TVariables>) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    const internalState: InternalState<TData, TVariables> = {\n      client,\n      query,\n      observable:\n        // See if there is an existing observable that was used to fetch the same\n        // data and if so, use it instead since it will contain the proper queryId\n        // to fetch the result set. This is used during SSR.\n        (renderPromises &&\n          renderPromises.getSSRObservable(makeWatchQueryOptions())) ||\n        client.watchQuery(\n          getObsQueryOptions(void 0, client, options, makeWatchQueryOptions())\n        ),\n      resultData: {\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: previous?.resultData.current?.data,\n      },\n    };\n\n    return internalState as InternalState<TData, TVariables>;\n  }\n\n  let [internalState, updateInternalState] =\n    React.useState(createInternalState);\n\n  /**\n   * Used by `useLazyQuery` when a new query is executed.\n   * We keep this logic here since it needs to update things in unsafe\n   * ways and here we at least can keep track of that in a single place.\n   */\n  function onQueryExecuted(\n    watchQueryOptions: WatchQueryOptions<TVariables, TData>\n  ) {\n    // this needs to be set to prevent an immediate `resubscribe` in the\n    // next rerender of the `useQuery` internals\n    Object.assign(internalState.observable, {\n      [lastWatchOptions]: watchQueryOptions,\n    });\n    const resultData = internalState.resultData;\n    updateInternalState({\n      ...internalState,\n      // might be a different query\n      query: watchQueryOptions.query,\n      resultData: Object.assign(resultData, {\n        // We need to modify the previous `resultData` object as we rely on the\n        // object reference in other places\n        previousData: resultData.current?.data || resultData.previousData,\n        current: undefined,\n      }),\n    });\n  }\n\n  if (client !== internalState.client || query !== internalState.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    const newInternalState = createInternalState(internalState);\n    updateInternalState(newInternalState);\n    return [newInternalState, onQueryExecuted] as const;\n  }\n\n  return [internalState, onQueryExecuted] as const;\n}\n\nexport function useQueryInternals<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const client = useApolloClient(options.client);\n\n  const renderPromises = React.useContext(getApolloContext()).renderPromises;\n  const isSyncSSR = !!renderPromises;\n  const disableNetworkFetches = client.disableNetworkFetches;\n  const ssrAllowed = options.ssr !== false && !options.skip;\n  const partialRefetch = options.partialRefetch;\n\n  const makeWatchQueryOptions = createMakeWatchQueryOptions(\n    client,\n    query,\n    options,\n    isSyncSSR\n  );\n\n  const [{ observable, resultData }, onQueryExecuted] = useInternalState(\n    client,\n    query,\n    options,\n    renderPromises,\n    makeWatchQueryOptions\n  );\n\n  const watchQueryOptions: Readonly<WatchQueryOptions<TVariables, TData>> =\n    makeWatchQueryOptions(observable);\n\n  useResubscribeIfNecessary<TData, TVariables>(\n    resultData, // might get mutated during render\n    observable, // might get mutated during render\n    client,\n    options,\n    watchQueryOptions\n  );\n\n  const obsQueryFields = React.useMemo<\n    Omit<ObservableQueryFields<TData, TVariables>, \"variables\">\n  >(() => bindObservableMethods(observable), [observable]);\n\n  useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n\n  const result = useObservableSubscriptionResult<TData, TVariables>(\n    resultData,\n    observable,\n    client,\n    options,\n    watchQueryOptions,\n    disableNetworkFetches,\n    partialRefetch,\n    isSyncSSR,\n    {\n      onCompleted: options.onCompleted || noop,\n      onError: options.onError || noop,\n    }\n  );\n\n  return {\n    result,\n    obsQueryFields,\n    observable,\n    resultData,\n    client,\n    onQueryExecuted,\n  };\n}\n\nfunction useObservableSubscriptionResult<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  resultData: InternalResult<TData, TVariables>,\n  observable: ObservableQuery<TData, TVariables>,\n  client: ApolloClient<object>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>,\n  watchQueryOptions: Readonly<WatchQueryOptions<TVariables, TData>>,\n  disableNetworkFetches: boolean,\n  partialRefetch: boolean | undefined,\n  isSyncSSR: boolean,\n  callbacks: {\n    onCompleted: (data: TData) => void;\n    onError: (error: ApolloError) => void;\n  }\n) {\n  const callbackRef = React.useRef<Callbacks<TData>>(callbacks);\n  React.useEffect(() => {\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    callbackRef.current = callbacks;\n  });\n\n  const resultOverride =\n    (\n      (isSyncSSR || disableNetworkFetches) &&\n      options.ssr === false &&\n      !options.skip\n    ) ?\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      ssrDisabledResult\n    : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      skipStandbyResult\n    : void 0;\n\n  const previousData = resultData.previousData;\n  const currentResultOverride = React.useMemo(\n    () =>\n      resultOverride &&\n      toQueryResult(resultOverride, previousData, observable, client),\n    [client, observable, resultOverride, previousData]\n  );\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (handleStoreChange) => {\n        // reference `disableNetworkFetches` here to ensure that the rules of hooks\n        // keep it as a dependency of this effect, even though it's not used\n        disableNetworkFetches;\n\n        if (isSyncSSR) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = resultData.current;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = observable.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          setResult(\n            result,\n            resultData,\n            observable,\n            client,\n            partialRefetch,\n            handleStoreChange,\n            callbackRef.current\n          );\n        };\n\n        const onError = (error: Error) => {\n          subscription.current.unsubscribe();\n          subscription.current = observable.resubscribeAfterError(\n            onNext,\n            onError\n          );\n\n          if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = resultData.current;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            setResult(\n              {\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              },\n              resultData,\n              observable,\n              client,\n              partialRefetch,\n              handleStoreChange,\n              callbackRef.current\n            );\n          }\n        };\n\n        // TODO evaluate if we keep this in\n        // React Compiler cannot handle scoped `let` access, but a mutable object\n        // like this is fine.\n        // was:\n        // let subscription = observable.subscribe(onNext, onError);\n        const subscription = { current: observable.subscribe(onNext, onError) };\n\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return () => {\n          setTimeout(() => subscription.current.unsubscribe());\n        };\n      },\n\n      [\n        disableNetworkFetches,\n        isSyncSSR,\n        observable,\n        resultData,\n        partialRefetch,\n        client,\n      ]\n    ),\n    () =>\n      currentResultOverride ||\n      getCurrentResult(\n        resultData,\n        observable,\n        callbackRef.current,\n        partialRefetch,\n        client\n      ),\n    () =>\n      currentResultOverride ||\n      getCurrentResult(\n        resultData,\n        observable,\n        callbackRef.current,\n        partialRefetch,\n        client\n      )\n  );\n}\n\nfunction useRegisterSSRObservable(\n  observable: ObsQueryWithMeta<any, any>,\n  renderPromises: RenderPromises | undefined,\n  ssrAllowed: boolean\n) {\n  if (renderPromises && ssrAllowed) {\n    renderPromises.registerSSRObservable(observable);\n\n    if (observable.getCurrentResult().loading) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      renderPromises.addObservableQueryPromise(observable);\n    }\n  }\n}\n\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  /** this hook will mutate properties on `resultData` */\n  resultData: InternalResult<TData, TVariables>,\n  /** this hook will mutate properties on `observable` */\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  client: ApolloClient<object>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>,\n  watchQueryOptions: Readonly<WatchQueryOptions<TVariables, TData>>\n) {\n  if (\n    observable[lastWatchOptions] &&\n    !equal(observable[lastWatchOptions], watchQueryOptions)\n  ) {\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    observable.reobserve(\n      getObsQueryOptions(observable, client, options, watchQueryOptions)\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    resultData.previousData =\n      resultData.current?.data || resultData.previousData;\n    resultData.current = void 0;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\n\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nexport function createMakeWatchQueryOptions<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient<object>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {},\n  isSyncSSR: boolean\n) {\n  return (\n    observable?: ObservableQuery<TData, TVariables>\n  ): WatchQueryOptions<TVariables, TData> => {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query });\n\n    if (\n      isSyncSSR &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      watchQueryOptions.initialFetchPolicy =\n        watchQueryOptions.initialFetchPolicy ||\n        watchQueryOptions.fetchPolicy ||\n        getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n      watchQueryOptions.fetchPolicy = \"standby\";\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        observable?.options.initialFetchPolicy ||\n        getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n    }\n\n    return watchQueryOptions;\n  };\n}\n\nexport function getObsQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  observable: ObservableQuery<TData, TVariables> | undefined,\n  client: ApolloClient<object>,\n  queryHookOptions: QueryHookOptions<TData, TVariables>,\n  watchQueryOptions: Partial<WatchQueryOptions<TVariables, TData>>\n): WatchQueryOptions<TVariables, TData> {\n  const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n  const globalDefaults = client.defaultOptions.watchQuery;\n  if (globalDefaults) toMerge.push(globalDefaults);\n\n  if (queryHookOptions.defaultOptions) {\n    toMerge.push(queryHookOptions.defaultOptions);\n  }\n\n  // We use compact rather than mergeOptions for this part of the merge,\n  // because we want watchQueryOptions.variables (if defined) to replace\n  // this.observable.options.variables whole. This replacement allows\n  // removing variables by removing them from the variables input to\n  // useQuery. If the variables were always merged together (rather than\n  // replaced), there would be no way to remove existing variables.\n  // However, the variables from options.defaultOptions and globalDefaults\n  // (if provided) should be merged, to ensure individual defaulted\n  // variables always have values, if not otherwise defined in\n  // observable.options or watchQueryOptions.\n  toMerge.push(compact(observable && observable.options, watchQueryOptions));\n\n  return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n}\n\nfunction setResult<TData, TVariables extends OperationVariables>(\n  nextResult: ApolloQueryResult<TData>,\n  resultData: InternalResult<TData, TVariables>,\n  observable: ObservableQuery<TData, TVariables>,\n  client: ApolloClient<object>,\n  partialRefetch: boolean | undefined,\n  forceUpdate: () => void,\n  callbacks: Callbacks<TData>\n) {\n  const previousResult = resultData.current;\n  if (previousResult && previousResult.data) {\n    resultData.previousData = previousResult.data;\n  }\n\n  if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });\n  }\n\n  resultData.current = toQueryResult(\n    unsafeHandlePartialRefetch(nextResult, observable, partialRefetch),\n    resultData.previousData,\n    observable,\n    client\n  );\n  // Calling state.setResult always triggers an update, though some call sites\n  // perform additional equality checks before committing to an update.\n  forceUpdate();\n  handleErrorOrCompleted(nextResult, previousResult?.networkStatus, callbacks);\n}\n\nfunction handleErrorOrCompleted<TData>(\n  result: ApolloQueryResult<TData>,\n  previousNetworkStatus: NetworkStatus | undefined,\n  callbacks: Callbacks<TData>\n) {\n  if (!result.loading) {\n    const error = toApolloError(result);\n\n    // wait a tick in case we are in the middle of rendering a component\n    Promise.resolve()\n      .then(() => {\n        if (error) {\n          callbacks.onError(error);\n        } else if (\n          result.data &&\n          previousNetworkStatus !== result.networkStatus &&\n          result.networkStatus === NetworkStatus.ready\n        ) {\n          callbacks.onCompleted(result.data);\n        }\n      })\n      .catch((error) => {\n        invariant.warn(error);\n      });\n  }\n}\n\nfunction getCurrentResult<TData, TVariables extends OperationVariables>(\n  resultData: InternalResult<TData, TVariables>,\n  observable: ObservableQuery<TData, TVariables>,\n  callbacks: Callbacks<TData>,\n  partialRefetch: boolean | undefined,\n  client: ApolloClient<object>\n): InternalQueryResult<TData, TVariables> {\n  // Using this.result as a cache ensures getCurrentResult continues returning\n  // the same (===) result object, unless state.setResult has been called, or\n  // we're doing server rendering and therefore override the result below.\n  if (!resultData.current) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    // this could call unsafeHandlePartialRefetch\n    setResult(\n      observable.getCurrentResult(),\n      resultData,\n      observable,\n      client,\n      partialRefetch,\n      () => {},\n      callbacks\n    );\n  }\n  return resultData.current!;\n}\n\nexport function getDefaultFetchPolicy<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  queryHookDefaultOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n  clientDefaultOptions?: DefaultOptions\n): WatchQueryFetchPolicy {\n  return (\n    queryHookDefaultOptions?.fetchPolicy ||\n    clientDefaultOptions?.watchQuery?.fetchPolicy ||\n    \"cache-first\"\n  );\n}\n\nexport function toApolloError<TData>(\n  result: Pick<ApolloQueryResult<TData>, \"errors\" | \"error\">\n): ApolloError | undefined {\n  return isNonEmptyArray(result.errors) ?\n      new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\nexport function toQueryResult<TData, TVariables extends OperationVariables>(\n  result: ApolloQueryResult<TData>,\n  previousData: TData | undefined,\n  observable: ObservableQuery<TData, TVariables>,\n  client: ApolloClient<object>\n): InternalQueryResult<TData, TVariables> {\n  const { data, partial, ...resultWithoutPartial } = result;\n  const queryResult: InternalQueryResult<TData, TVariables> = {\n    data, // Ensure always defined, even if result.data is missing.\n    ...resultWithoutPartial,\n    client: client,\n    observable: observable,\n    variables: observable.variables,\n    called: result !== ssrDisabledResult && result !== skipStandbyResult,\n    previousData,\n  };\n  return queryResult;\n}\n\nfunction unsafeHandlePartialRefetch<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  result: ApolloQueryResult<TData>,\n  observable: ObservableQuery<TData, TVariables>,\n  partialRefetch: boolean | undefined\n): ApolloQueryResult<TData> {\n  // TODO: This code should be removed when the partialRefetch option is\n  // removed. I was unable to get this hook to behave reasonably in certain\n  // edge cases when this block was put in an effect.\n  if (\n    result.partial &&\n    partialRefetch &&\n    !result.loading &&\n    (!result.data || Object.keys(result.data).length === 0) &&\n    observable.options.fetchPolicy !== \"cache-only\"\n  ) {\n    observable.refetch();\n    return {\n      ...result,\n      loading: true,\n      networkStatus: NetworkStatus.refetch,\n    };\n  }\n  return result;\n}\n\nconst ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0 as any,\n  error: void 0,\n  networkStatus: NetworkStatus.loading,\n});\n\nconst skipStandbyResult = maybeDeepFreeze({\n  loading: false,\n  data: void 0 as any,\n  error: void 0,\n  networkStatus: NetworkStatus.ready,\n});\n\nfunction bindObservableMethods<TData, TVariables extends OperationVariables>(\n  observable: ObservableQuery<TData, TVariables>\n) {\n  return {\n    refetch: observable.refetch.bind(observable),\n    reobserve: observable.reobserve.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable),\n  };\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\n\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n        // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n      // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n} from \"graphql\";\nimport {\n  AutoCleanedWeakCache,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport { registerGlobalCache } from \"../../utilities/caching/getMemoryInternals.js\";\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription,\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nlet cache:\n  | undefined\n  | AutoCleanedWeakCache<\n      DocumentNode,\n      {\n        name: string;\n        type: DocumentType;\n        variables: readonly VariableDefinitionNode[];\n      }\n    >;\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = \"Query\";\n      break;\n    case DocumentType.Mutation:\n      name = \"Mutation\";\n      break;\n    case DocumentType.Subscription:\n      name = \"Subscription\";\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  if (!cache) {\n    cache = new AutoCleanedWeakCache(\n      cacheSizes.parser || defaultCacheSizes.parser\n    );\n  }\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of %s passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`,\n    document\n  );\n\n  const fragments: DefinitionNode[] = [];\n  const queries: DefinitionNode[] = [];\n  const mutations: DefinitionNode[] = [];\n  const subscriptions: DefinitionNode[] = [];\n\n  for (const x of document.definitions) {\n    if (x.kind === \"FragmentDefinition\") {\n      fragments.push(x);\n      continue;\n    }\n\n    if (x.kind === \"OperationDefinition\") {\n      switch (x.operation) {\n        case \"query\":\n          queries.push(x);\n          break;\n        case \"mutation\":\n          mutations.push(x);\n          break;\n        case \"subscription\":\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      queries.length ||\n      mutations.length ||\n      subscriptions.length,\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `%s had %s queries, %s ` +\n      `subscriptions and %s mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    queries.length,\n    subscriptions.length,\n    mutations.length\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions =\n    queries.length ? queries\n    : mutations.length ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. %s had ` +\n      `%s definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    definitions.length\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === \"Name\") {\n    name = definition.name.value;\n  } else {\n    name = \"data\"; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nparser.resetCache = () => {\n  cache = undefined;\n};\n\nif (__DEV__) {\n  registerGlobalCache(\"parser\", () => (cache ? cache.size : 0));\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a %s requires a graphql ` + `%s, but a %s was used instead.`,\n    requiredOperationName,\n    requiredOperationName,\n    usedOperationName\n  );\n}\n", "import type { DependencyList } from \"react\";\nimport * as React from \"rehackt\";\nimport { equal } from \"@wry/equality\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>();\n\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    ref.current = { value: memoFn(), deps };\n  }\n\n  return ref.current.value;\n}\n", "import * as React from \"rehackt\";\nimport { canUseDOM } from \"../../../utilities/index.js\";\n\n// use canUseDOM here instead of canUseLayoutEffect because we want to be able\n// to use useLayoutEffect in our jest tests. useLayoutEffect seems to work fine\n// in useSuspenseQuery tests, but to honor the original comment about the\n// warnings for useSyncExternalStore implementation, canUseLayoutEffect is left\n// alone.\nexport const useIsomorphicLayoutEffect =\n  canUseDOM ? React.useLayoutEffect : React.useEffect;\n", "import * as React from \"rehackt\";\n\nlet Ctx: React.Context<null>;\n\nfunction noop() {}\nexport function useRenderGuard() {\n  if (!Ctx) {\n    // we want the intialization to be lazy because `createContext` would error on import in a RSC\n    Ctx = React.createContext(null);\n  }\n\n  return React.useCallback(\n    /**\n     * @returns true if the hook was called during render\n     */ () => {\n      const orig = console.error;\n      try {\n        console.error = noop;\n\n        /**\n         * `useContext` can be called conditionally during render, so this is safe.\n         * (Also, during render we would want to throw as a reaction to this anyways, so it\n         * wouldn't even matter if we got the order of hooks mixed up...)\n         *\n         * They cannot however be called outside of Render, and that's what we're testing here.\n         *\n         * Different versions of React have different behaviour on an invalid hook call:\n         *\n         * React 16.8 - 17: throws an error\n         * https://github.com/facebook/react/blob/2b93d686e359c7afa299e2ec5cf63160a32a1155/packages/react/src/ReactHooks.js#L18-L26\n         *\n         * React 18 & 19: `console.error` in development, then `resolveDispatcher` returns `null` and a member access on `null` throws.\n         * https://github.com/facebook/react/blob/58e8304483ebfadd02a295339b5e9a989ac98c6e/packages/react/src/ReactHooks.js#L28-L35\n         */\n        React[\"useContext\" /* hide this from the linter */](Ctx);\n        return true;\n      } catch (e) {\n        return false;\n      } finally {\n        console.error = orig;\n      }\n    },\n    []\n  );\n}\n", "import { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport * as React from \"rehackt\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n// Prevent webpack from complaining about our feature detection of the\n// use property of the React namespace, which is expected not\n// to exist when using current stable versions, and that's fine.\nconst useKey = \"use\" as keyof typeof React;\nconst realHook = React[useKey] as Use | undefined;\n\n// This is named with two underscores to allow this hook to evade typical rules of\n// hooks (i.e. it can be used conditionally)\nexport const __use =\n  realHook ||\n  function __use<TValue>(promise: Promise<TValue>) {\n    const statefulPromise = wrapPromiseWithState(promise);\n\n    switch (statefulPromise.status) {\n      case \"pending\":\n        throw statefulPromise;\n      case \"rejected\":\n        throw statefulPromise.reason;\n      case \"fulfilled\":\n        return statefulPromise.value;\n    }\n  };\n", "import type {\n  useQuery,\n  useSuspenseQuery,\n  useBackgroundQuery,\n  useReadQuery,\n  useFragment,\n  useQueryRefHandlers,\n} from \"../index.js\";\nimport type { QueryManager } from \"../../../core/QueryManager.js\";\nimport type { ApolloClient } from \"../../../core/ApolloClient.js\";\nimport type { ObservableQuery } from \"../../../core/ObservableQuery.js\";\nimport type { createQueryPreloader } from \"../../query-preloader/createQueryPreloader.js\";\n\nconst wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\n\ninterface WrappableHooks {\n  createQueryPreloader: typeof createQueryPreloader;\n  useQuery: typeof useQuery;\n  useSuspenseQuery: typeof useSuspenseQuery;\n  useBackgroundQuery: typeof useBackgroundQuery;\n  useReadQuery: typeof useReadQuery;\n  useFragment: typeof useFragment;\n  useQueryRefHandlers: typeof useQueryRefHandlers;\n}\n\n/**\n * @internal\n * Can be used to correctly type the [Symbol.for(\"apollo.hook.wrappers\")] property of\n * `QueryManager`, to override/wrap hook functionality.\n */\nexport type HookWrappers = {\n  [K in keyof WrappableHooks]?: (\n    originalHook: WrappableHooks[K]\n  ) => WrappableHooks[K];\n};\n\ninterface QueryManagerWithWrappers<T> extends QueryManager<T> {\n  [wrapperSymbol]?: HookWrappers;\n}\n\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook<Hook extends (...args: any[]) => any>(\n  hookName: keyof WrappableHooks,\n  useHook: Hook,\n  clientOrObsQuery: ObservableQuery<any> | ApolloClient<any>\n): Hook {\n  const queryManager = (\n    clientOrObsQuery as unknown as {\n      // both `ApolloClient` and `ObservableQuery` have a `queryManager` property\n      // but they're both `private`, so we have to cast around for a bit here.\n      queryManager: QueryManagerWithWrappers<any>;\n    }\n  )[\"queryManager\"];\n  const wrappers = queryManager && queryManager[wrapperSymbol];\n  const wrapper: undefined | ((wrap: Hook) => Hook) =\n    wrappers && (wrappers[hookName] as any);\n  return wrapper ? wrapper(useHook) : useHook;\n}\n", "import * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport type {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport type {\n  ApolloCache,\n  DefaultContext,\n  MutationOptions,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n\n/**\n *\n *\n * > Refer to the [Mutations](https://www.apollographql.com/docs/react/data/mutations/) section for a more in-depth overview of `useMutation`.\n *\n * @example\n * ```jsx\n * import { gql, useMutation } from '@apollo/client';\n *\n * const ADD_TODO = gql`\n *   mutation AddTodo($type: String!) {\n *     addTodo(type: $type) {\n *       id\n *       type\n *     }\n *   }\n * `;\n *\n * function AddTodo() {\n *   let input;\n *   const [addTodo, { data }] = useMutation(ADD_TODO);\n *\n *   return (\n *     <div>\n *       <form\n *         onSubmit={e => {\n *           e.preventDefault();\n *           addTodo({ variables: { type: input.value } });\n *           input.value = '';\n *         }}\n *       >\n *         <input\n *           ref={node => {\n *             input = node;\n *           }}\n *         />\n *         <button type=\"submit\">Add Todo</button>\n *       </form>\n *     </div>\n *   );\n * }\n * ```\n * @since 3.0.0\n * @param mutation - A GraphQL mutation document parsed into an AST by `gql`.\n * @param options - Options to control how the mutation is executed.\n * @returns A tuple in the form of `[mutate, result]`\n */\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>,\n    TContext,\n    TCache\n  >\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = React.useState<Omit<MutationResult, \"reset\">>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = React.useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(ref.current, { client, options, mutation });\n  });\n\n  const execute = React.useCallback(\n    (\n      executeOptions: MutationFunctionOptions<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      > = {}\n    ) => {\n      const { options, mutation } = ref.current;\n      const baseOptions = { ...options, mutation };\n      const client = executeOptions.client || ref.current.client;\n\n      if (\n        !ref.current.result.loading &&\n        !baseOptions.ignoreResults &&\n        ref.current.isMounted\n      ) {\n        setResult(\n          (ref.current.result = {\n            loading: true,\n            error: void 0,\n            data: void 0,\n            called: true,\n            client,\n          })\n        );\n      }\n\n      const mutationId = ++ref.current.mutationId;\n      const clientOptions = mergeOptions(baseOptions, executeOptions);\n\n      return client\n        .mutate(clientOptions as MutationOptions<TData, OperationVariables>)\n        .then((response) => {\n          const { data, errors } = response;\n          const error =\n            errors && errors.length > 0 ?\n              new ApolloError({ graphQLErrors: errors })\n            : void 0;\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (error && onError) {\n            onError(\n              error,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n          }\n\n          if (\n            mutationId === ref.current.mutationId &&\n            !clientOptions.ignoreResults\n          ) {\n            const result = {\n              called: true,\n              loading: false,\n              data,\n              error,\n              client,\n            };\n\n            if (ref.current.isMounted && !equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onCompleted =\n            executeOptions.onCompleted || ref.current.options?.onCompleted;\n\n          if (!error) {\n            onCompleted?.(\n              response.data!,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n          }\n\n          return response;\n        })\n        .catch((error) => {\n          if (mutationId === ref.current.mutationId && ref.current.isMounted) {\n            const result = {\n              loading: false,\n              error,\n              data: void 0,\n              called: true,\n              client,\n            };\n\n            if (!equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (onError) {\n            onError(\n              error,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n\n            // TODO(brian): why are we returning this here???\n            return { data: void 0, errors: error };\n          }\n\n          throw error;\n        });\n    },\n    []\n  );\n\n  const reset = React.useCallback(() => {\n    if (ref.current.isMounted) {\n      const result = {\n        called: false,\n        loading: false,\n        client: ref.current.client,\n      };\n      Object.assign(ref.current, { mutationId: 0, result });\n      setResult(result);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    const current = ref.current;\n    current.isMounted = true;\n\n    return () => {\n      current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type {\n  ApolloClient,\n  DefaultContext,\n  ErrorPolicy,\n  FetchPolicy,\n  FetchResult,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { ApolloError, Observable } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { toApolloError } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n * @remarks\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(\n *     query,\n *     {\n *       onData({ data }) {\n *         setAccumulatedData((prev) => [...prev, data])\n *       }\n *     }\n *   );\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @since 3.0.0\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SubscriptionHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options.onSubscriptionData) {\n      invariant.warn(\n        options.onData ?\n          \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n        : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete ?\n          \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n        : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const {\n    skip,\n    fetchPolicy,\n    errorPolicy,\n    shouldResubscribe,\n    context,\n    extensions,\n    ignoreResults,\n  } = options;\n  const variables = useDeepMemo(() => options.variables, [options.variables]);\n\n  const recreate = () =>\n    createSubscription(\n      client,\n      subscription,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      context,\n      extensions\n    );\n\n  let [observable, setObservable] = React.useState(\n    options.skip ? null : recreate\n  );\n\n  const recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(() => {\n    recreateRef.current = recreate;\n  });\n\n  if (skip) {\n    if (observable) {\n      setObservable((observable = null));\n    }\n  } else if (\n    !observable ||\n    ((client !== observable.__.client ||\n      subscription !== observable.__.query ||\n      fetchPolicy !== observable.__.fetchPolicy ||\n      errorPolicy !== observable.__.errorPolicy ||\n      !equal(variables, observable.__.variables)) &&\n      (typeof shouldResubscribe === \"function\" ?\n        !!shouldResubscribe(options!)\n      : shouldResubscribe) !== false)\n  ) {\n    setObservable((observable = recreate()));\n  }\n\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n\n  const fallbackLoading = !skip && !ignoreResults;\n  const fallbackResult = React.useMemo<SubscriptionResult<TData, TVariables>>(\n    () => ({\n      loading: fallbackLoading,\n      error: void 0,\n      data: void 0,\n      variables,\n    }),\n    [fallbackLoading, variables]\n  );\n\n  const ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(() => {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n\n  const ret = useSyncExternalStore<SubscriptionResult<TData, TVariables>>(\n    React.useCallback(\n      (update) => {\n        if (!observable) {\n          return () => {};\n        }\n\n        let subscriptionStopped = false;\n        const variables = observable.__.variables;\n        const client = observable.__.client;\n        const subscription = observable.subscribe({\n          next(fetchResult) {\n            if (subscriptionStopped) {\n              return;\n            }\n\n            const result = {\n              loading: false,\n              // TODO: fetchResult.data can be null but SubscriptionResult.data\n              // expects TData | undefined only\n              data: fetchResult.data!,\n              error: toApolloError(fetchResult),\n              variables,\n            };\n            observable.__.setResult(result);\n            if (!ignoreResultsRef.current) update();\n\n            if (result.error) {\n              optionsRef.current.onError?.(result.error);\n            } else if (optionsRef.current.onData) {\n              optionsRef.current.onData({\n                client,\n                data: result,\n              });\n            } else if (optionsRef.current.onSubscriptionData) {\n              optionsRef.current.onSubscriptionData({\n                client,\n                subscriptionData: result,\n              });\n            }\n          },\n          error(error) {\n            error =\n              error instanceof ApolloError ? error : (\n                new ApolloError({ protocolErrors: [error] })\n              );\n            if (!subscriptionStopped) {\n              observable.__.setResult({\n                loading: false,\n                data: void 0,\n                error,\n                variables,\n              });\n              if (!ignoreResultsRef.current) update();\n              optionsRef.current.onError?.(error);\n            }\n          },\n          complete() {\n            if (!subscriptionStopped) {\n              if (optionsRef.current.onComplete) {\n                optionsRef.current.onComplete();\n              } else if (optionsRef.current.onSubscriptionComplete) {\n                optionsRef.current.onSubscriptionComplete();\n              }\n            }\n          },\n        });\n\n        return () => {\n          // immediately stop receiving subscription values, but do not unsubscribe\n          // until after a short delay in case another useSubscription hook is\n          // reusing the same underlying observable and is about to subscribe\n          subscriptionStopped = true;\n          setTimeout(() => {\n            subscription.unsubscribe();\n          });\n        };\n      },\n      [observable]\n    ),\n    () =>\n      observable && !skip && !ignoreResults ?\n        observable.__.result\n      : fallbackResult,\n    () => fallbackResult\n  );\n\n  const restart = React.useCallback(() => {\n    invariant(\n      !optionsRef.current.skip,\n      \"A subscription that is skipped cannot be restarted.\"\n    );\n    setObservable(recreateRef.current());\n  }, [optionsRef, recreateRef]);\n\n  return React.useMemo(() => ({ ...ret, restart }), [ret, restart]);\n}\n\nfunction createSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient<any>,\n  query: TypedDocumentNode<TData, TVariables>,\n  variables: TVariables | undefined,\n  fetchPolicy: FetchPolicy | undefined,\n  errorPolicy: ErrorPolicy | undefined,\n  context: DefaultContext | undefined,\n  extensions: Record<string, any> | undefined\n) {\n  const options = {\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    context,\n    extensions,\n  };\n  const __ = {\n    ...options,\n    client,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      variables,\n    } as SubscriptionResult<TData, TVariables>,\n    setResult(result: SubscriptionResult<TData, TVariables>) {\n      __.result = result;\n    },\n  };\n\n  let observable: Observable<FetchResult<TData>> | null = null;\n  return Object.assign(\n    new Observable<FetchResult<TData>>((observer) => {\n      // lazily start the subscription when the first observer subscribes\n      // to get around strict mode\n      if (!observable) {\n        observable = client.subscribe(options);\n      }\n      const sub = observable.subscribe(observer);\n      return () => sub.unsubscribe();\n    }),\n    {\n      /**\n       * A tracking object to store details about the observable and the latest result of the subscription.\n       */\n      __,\n    }\n  );\n}\n", "import * as React from \"rehackt\";\nimport type { ReactiveVar } from \"../../core/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\n/**\n * Reads the value of a [reactive variable](https://www.apollographql.com/docs/react/local-state/reactive-variables/) and re-renders the containing component whenever that variable's value changes. This enables a reactive variable to trigger changes _without_ relying on the `useQuery` hook.\n *\n * @example\n * ```jsx\n * import { makeVar, useReactiveVar } from \"@apollo/client\";\n * export const cartItemsVar = makeVar([]);\n *\n * export function Cart() {\n *   const cartItems = useReactiveVar(cartItemsVar);\n *   // ...\n * }\n * ```\n * @since 3.2.0\n * @param rv - A reactive variable.\n * @returns The current value of the reactive variable.\n */\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  return useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        // By reusing the same onNext function in the nested call to\n        // rv.onNextChange(onNext), we can keep using the initial clean-up function\n        // returned by rv.onNextChange(function onNext(v){...}), without having to\n        // register the new clean-up function (returned by the nested\n        // rv.onNextChange(onNext)) with yet another callback.\n        return rv.onNextChange(function onNext() {\n          update();\n          rv.onNextChange(onNext);\n        });\n      },\n      [rv]\n    ),\n    rv,\n    rv\n  );\n}\n", "import * as React from \"rehackt\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport type {\n  Cache,\n  Reference,\n  StoreObject,\n  MissingTree,\n} from \"../../cache/index.js\";\n\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { ApolloClient, OperationVariables } from \"../../core/index.js\";\nimport type { NoInfer } from \"../types/types.js\";\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport equal from \"@wry/equality\";\n\nexport interface UseFragmentOptions<TData, TVars>\n  extends Omit<\n      Cache.DiffOptions<NoInfer<TData>, NoInfer<TVars>>,\n      \"id\" | \"query\" | \"optimistic\" | \"previousResult\" | \"returnPartialData\"\n    >,\n    Omit<\n      Cache.ReadFragmentOptions<TData, TVars>,\n      \"id\" | \"variables\" | \"returnPartialData\"\n    > {\n  from: StoreObject | Reference | string;\n  // Override this field to make it optional (default: true).\n  optimistic?: boolean;\n  /**\n   * The instance of `ApolloClient` to use to look up the fragment.\n   *\n   * By default, the instance that's passed down via context is used, but you\n   * can provide a different instance here.\n   *\n   * @docGroup 1. Operation options\n   */\n  client?: ApolloClient<any>;\n}\n\nexport type UseFragmentResult<TData> =\n  | {\n      data: TData;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<TData>;\n      complete: false;\n      missing?: MissingTree;\n    };\n\nexport function useFragment<TData = any, TVars = OperationVariables>(\n  options: UseFragmentOptions<TData, TVars>\n): UseFragmentResult<TData> {\n  return wrapHook(\n    \"useFragment\",\n    _useFragment,\n    useApolloClient(options.client)\n  )(options);\n}\n\nfunction _useFragment<TData = any, TVars = OperationVariables>(\n  options: UseFragmentOptions<TData, TVars>\n): UseFragmentResult<TData> {\n  const { cache } = useApolloClient(options.client);\n  const { from, ...rest } = options;\n\n  // We calculate the cache id seperately from `stableOptions` because we don't\n  // want changes to non key fields in the `from` property to affect\n  // `stableOptions` and retrigger our subscription. If the cache identifier\n  // stays the same between renders, we want to reuse the existing subscription.\n  const id = React.useMemo(\n    () => (typeof from === \"string\" ? from : cache.identify(from)),\n    [cache, from]\n  );\n\n  const stableOptions = useDeepMemo(() => ({ ...rest, from: id! }), [rest, id]);\n\n  // Since .next is async, we need to make sure that we\n  // get the correct diff on the next render given new diffOptions\n  const diff = React.useMemo(() => {\n    const { fragment, fragmentName, from, optimistic = true } = stableOptions;\n\n    return {\n      result: diffToResult(\n        cache.diff<TData>({\n          ...stableOptions,\n          returnPartialData: true,\n          id: from,\n          query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n          optimistic,\n        })\n      ),\n    };\n  }, [stableOptions, cache]);\n\n  // Used for both getSnapshot and getServerSnapshot\n  const getSnapshot = React.useCallback(() => diff.result, [diff]);\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        let lastTimeout = 0;\n        const subscription = cache.watchFragment(stableOptions).subscribe({\n          next: (result) => {\n            // Since `next` is called async by zen-observable, we want to avoid\n            // unnecessarily rerendering this hook for the initial result\n            // emitted from watchFragment which should be equal to\n            // `diff.result`.\n            if (equal(result, diff.result)) return;\n            diff.result = result;\n            // If we get another update before we've re-rendered, bail out of\n            // the update and try again. This ensures that the relative timing\n            // between useQuery and useFragment stays roughly the same as\n            // fixed in https://github.com/apollographql/apollo-client/pull/11083\n            clearTimeout(lastTimeout);\n            lastTimeout = setTimeout(forceUpdate) as any;\n          },\n        });\n        return () => {\n          subscription.unsubscribe();\n          clearTimeout(lastTimeout);\n        };\n      },\n      [cache, stableOptions, diff]\n    ),\n    getSnapshot,\n    getSnapshot\n  );\n}\n\nfunction diffToResult<TData>(\n  diff: Cache.DiffResult<TData>\n): UseFragmentResult<TData> {\n  const result = {\n    data: diff.result!,\n    complete: !!diff.complete,\n  } as UseFragmentResult<TData>;\n\n  if (diff.missing) {\n    result.missing = mergeDeepArray(diff.missing.map((error) => error.missing));\n  }\n\n  return result;\n}\n", "import * as React from \"rehackt\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../internal/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey, QueryKey } from \"../internal/index.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: TData;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: TData,\n      options: {\n        fetchMoreResult: TData;\n        variables: TVariables;\n      }\n    ) => TData;\n  }\n) => Promise<ApolloQueryResult<TData>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ?\n    TOptions[\"skip\"] extends boolean ?\n      DeepPartial<TData> | undefined\n    : DeepPartial<TData>\n  : TOptions[\"skip\"] extends boolean ? TData | undefined\n  : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  return wrapHook(\n    \"useSuspenseQuery\",\n    _useSuspenseQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables>\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  let [current, setPromise] = React.useState<\n    [QueryKey, Promise<ApolloQueryResult<any>>]\n  >([queryRef.key, queryRef.promise]);\n\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  let promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromise([queryRef.key, promise]);\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore = React.useCallback<\n    FetchMoreFunction<unknown, OperationVariables>\n  >(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  ) as FetchMoreFunction<TData | undefined, TVariables>;\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore = queryRef.observable.subscribeToMore;\n\n  return React.useMemo<\n    UseSuspenseQueryResult<TData | undefined, TVariables>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors) ?\n      new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n", "import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../../core/index.js\";\nimport type {\n  ObservableSubscription,\n  PromiseWithState,\n} from \"../../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../../utilities/index.js\";\nimport type { QueryKey } from \"./types.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport { invariant } from \"../../../utilities/globals/invariantWrappers.js\";\n\ntype QueryRefPromise<TData> = PromiseWithState<ApolloQueryResult<TData>>;\n\ntype Listener<TData> = (promise: QueryRefPromise<TData>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\nconst PROMISE_SYMBOL: unique symbol = Symbol();\ndeclare const QUERY_REF_BRAND: unique symbol;\n/**\n * A `QueryReference` is an opaque object returned by `useBackgroundQuery`.\n * A child component reading the `QueryReference` via `useReadQuery` will\n * suspend until the promise resolves.\n */\nexport interface QueryRef<TData = unknown, TVariables = unknown> {\n  /** @internal */\n  [QUERY_REF_BRAND]?(variables: TVariables): TData;\n}\n\n/**\n * @internal\n * For usage in internal helpers only.\n */\ninterface WrappedQueryRef<TData = unknown, TVariables = unknown>\n  extends QueryRef<TData, TVariables> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData>;\n  /** @internal */\n  toPromise?(): Promise<unknown>;\n}\n\n/**\n * @deprecated Please use the `QueryRef` interface instead of `QueryReference`.\n *\n * {@inheritDoc @apollo/client!QueryRef:interface}\n */\nexport interface QueryReference<TData = unknown, TVariables = unknown>\n  extends QueryRef<TData, TVariables> {\n  /**\n   * @deprecated Please use the `QueryRef` interface instead of `QueryReference`.\n   *\n   * {@inheritDoc @apollo/client!PreloadedQueryRef#toPromise:member(1)}\n   */\n  toPromise?: unknown;\n}\n\n/**\n * {@inheritDoc @apollo/client!QueryRef:interface}\n */\nexport interface PreloadedQueryRef<TData = unknown, TVariables = unknown>\n  extends QueryRef<TData, TVariables> {\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return queryRef.toPromise();\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   *\n   * @since 3.9.0\n   */\n  toPromise(): Promise<PreloadedQueryRef<TData, TVariables>>;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData, TVariables extends OperationVariables>(\n  internalQueryRef: InternalQueryReference<TData>\n) {\n  const ref: WrappedQueryRef<TData, TVariables> = {\n    toPromise() {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(() => ref);\n    },\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  };\n\n  return ref;\n}\n\nexport function assertWrappedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables>\n): asserts queryRef is WrappedQueryRef<TData, TVariables>;\nexport function assertWrappedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables> | undefined | null\n): asserts queryRef is WrappedQueryRef<TData, TVariables> | undefined | null;\nexport function assertWrappedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables> | undefined | null\n) {\n  invariant(\n    !queryRef || QUERY_REFERENCE_SYMBOL in queryRef,\n    \"Expected a QueryRef object, but got something else instead.\"\n  );\n}\n\nexport function getWrappedPromise<TData>(\n  queryRef: WrappedQueryRef<TData, any>\n) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: WrappedQueryRef<TData>\n): InternalQueryReference<TData>;\nexport function unwrapQueryRef<TData>(\n  queryRef: Partial<WrappedQueryRef<TData>>\n): undefined | InternalQueryReference<TData>;\nexport function unwrapQueryRef<TData>(\n  queryRef: Partial<WrappedQueryRef<TData>>\n) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<TData>(\n  queryRef: WrappedQueryRef<TData>,\n  promise: QueryRefPromise<TData>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result!: ApolloQueryResult<TData>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData>;\n\n  private subscription!: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n  private softReferences = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests =\n      originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n\n    try {\n      if (avoidNetworkRequests) {\n        observable.silentSetOptions({ fetchPolicy: \"standby\" });\n      } else {\n        observable.resetLastResults();\n        observable.silentSetOptions({ fetchPolicy: \"cache-first\" });\n      }\n\n      this.subscribeToQuery();\n\n      if (avoidNetworkRequests) {\n        return;\n      }\n\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        option in watchQueryOptions &&\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.promise.status) {\n      case \"pending\": {\n        this.reject?.(error);\n        break;\n      }\n      default: {\n        this.promise = createRejectedPromise<ApolloQueryResult<TData>>(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then(() => {\n        // In the case of `fetchMore`, this promise is resolved before a cache\n        // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n        // fetch policy and runs `cache.batch` in its `.then` handler. Because\n        // the timing is different, we accidentally run this update twice\n        // causing an additional re-render with the `fetchMore` result by\n        // itself. By wrapping in `setTimeout`, this should provide a short\n        // delay to allow the `QueryInfo.notify` handler to run before this\n        // promise is checked.\n        // See https://github.com/apollographql/apollo-client/issues/11315 for\n        // more information\n        setTimeout(() => {\n          if (this.promise.status === \"pending\") {\n            // Use the current result from the observable instead of the value\n            // resolved from the promise. This avoids issues in some cases where\n            // the raw resolved value should not be the emitted value, such as\n            // when a `fetchMore` call returns an empty array after it has\n            // reached the end of the list.\n            //\n            // See the following for more information:\n            // https://github.com/apollographql/apollo-client/issues/11642\n            this.result = this.observable.getCurrentResult();\n            this.resolve?.(this.result);\n          }\n        });\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .filter(\n        (result) => !equal(result.data, {}) && !equal(result, this.result)\n      )\n      .subscribe(this.handleNext, this.handleError);\n  }\n\n  private setResult() {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    const result = this.observable.getCurrentResult(false);\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      (\n        result.data &&\n        (!result.partial || this.watchQueryOptions.returnPartialData)\n      ) ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private createPendingPromise() {\n    return wrapPromiseWithState(\n      new Promise<ApolloQueryResult<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n}\n", "import { Trie } from \"@wry/trie\";\nimport type { ObservableQuery } from \"../../../core/index.js\";\nimport { canUseWeakMap } from \"../../../utilities/index.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>(\n    canUseWeakMap\n  );\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = Object.create(null)) {\n    this.options = options;\n  }\n\n  getQueryRef<TData = any>(\n    cacheKey: CacheKey,\n    createObservable: () => ObservableQuery<TData>\n  ) {\n    const ref = this.queryRefs.lookupArray(cacheKey) as {\n      current?: InternalQueryReference<TData>;\n    };\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  add(cacheKey: CacheKey, queryRef: InternalQueryReference<unknown>) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n    ref.current = queryRef;\n  }\n}\n", "import type { SuspenseCacheOptions } from \"../index.js\";\nimport { SuspenseCache } from \"./SuspenseCache.js\";\nimport type { ApolloClient } from \"../../../core/ApolloClient.js\";\n\ndeclare module \"../../../core/ApolloClient.js\" {\n  interface DefaultOptions {\n    react?: {\n      suspense?: Readonly<SuspenseCacheOptions>;\n    };\n  }\n}\n\nconst suspenseCacheSymbol = Symbol.for(\"apollo.suspenseCache\");\n\nexport function getSuspenseCache(\n  client: ApolloClient<object> & {\n    [suspenseCacheSymbol]?: SuspenseCache;\n  }\n) {\n  if (!client[suspenseCacheSymbol]) {\n    client[suspenseCacheSymbol] = new SuspenseCache(\n      client.defaultOptions.react?.suspense\n    );\n  }\n\n  return client[suspenseCacheSymbol];\n}\n", "export const skipToken = Symbol.for(\"apollo.skipToken\");\nexport type SkipToken = typeof skipToken;\n", "import * as React from \"rehackt\";\nimport type {\n  DocumentNode,\n  FetchMoreQueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { CacheKey, QueryRef } from \"../internal/index.js\";\nimport type { BackgroundQueryHookOptions, NoInfer } from \"../types/types.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type {\n  FetchMoreFunction,\n  RefetchFunction,\n  SubscribeToMoreFunction,\n} from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport type { SkipToken } from \"./constants.js\";\n\nexport type UseBackgroundQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n};\n\ntype BackgroundQueryHookOptionsNoInfer<\n  TData,\n  TVariables extends OperationVariables,\n> = BackgroundQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>;\n\nexport function useBackgroundQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<BackgroundQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & TOptions\n): [\n  (\n    | QueryRef<\n        TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n          TOptions[\"returnPartialData\"] extends true ?\n            DeepPartial<TData> | undefined\n          : TData | undefined\n        : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n        : TData,\n        TVariables\n      >\n    | (TOptions[\"skip\"] extends boolean ? undefined : never)\n  ),\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<DeepPartial<TData> | undefined, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData | undefined, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): [\n  QueryRef<DeepPartial<TData>, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n  }\n): [\n  QueryRef<DeepPartial<TData>, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n  }\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [QueryRef<TData, TVariables>, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n        returnPartialData: true;\n      })\n): [\n  QueryRef<DeepPartial<TData>, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables> = Object.create(null)\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  return wrapHook(\n    \"useBackgroundQuery\",\n    _useBackgroundQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions as WatchQueryOptions<any, any>)\n  );\n\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(\n    wrapQueryRef(queryRef)\n  );\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n\n  // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n  React.useEffect(() => {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    const id = setTimeout(() => {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n\n    return () => clearTimeout(id);\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options as FetchMoreQueryOptions<any>);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  React.useEffect(() => queryRef.softRetain(), [queryRef]);\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    {\n      fetchMore,\n      refetch,\n      subscribeToMore: queryRef.observable.subscribeToMore,\n    },\n  ];\n}\n", "import * as React from \"rehackt\";\nimport type {\n  DocumentNode,\n  FetchMoreQueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  assertWrappedQueryRef,\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { CacheKey, QueryRef } from \"../internal/index.js\";\nimport type { LoadableQueryHookOptions } from \"../types/types.js\";\nimport { __use, useRenderGuard } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type {\n  FetchMoreFunction,\n  RefetchFunction,\n  SubscribeToMoreFunction,\n} from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type {\n  DeepPartial,\n  OnlyRequiredProperties,\n} from \"../../utilities/index.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n\nexport type LoadQueryFunction<TVariables extends OperationVariables> = (\n  // Use variadic args to handle cases where TVariables is type `never`, in\n  // which case we don't want to allow a variables argument. In other\n  // words, we don't want to allow variables to be passed as an argument to this\n  // function if the query does not expect variables in the document.\n  ...args: [TVariables] extends [never] ? []\n  : {} extends OnlyRequiredProperties<TVariables> ? [variables?: TVariables]\n  : [variables: TVariables]\n) => void;\n\ntype ResetFunction = () => void;\n\nexport type UseLoadableQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = [\n  loadQuery: LoadQueryFunction<TVariables>,\n  queryRef: QueryRef<TData, TVariables> | null,\n  handlers: {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n    refetch: RefetchFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n    subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n    /**\n     * A function that resets the `queryRef` back to `null`.\n     */\n    reset: ResetFunction;\n  },\n];\n\nexport function useLoadableQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends LoadableQueryHookOptions,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LoadableQueryHookOptions & TOptions\n): UseLoadableQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n  : TData,\n  TVariables\n>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseLoadableQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseLoadableQueryResult<TData | undefined, TVariables>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions & {\n    returnPartialData: true;\n  }\n): UseLoadableQueryResult<DeepPartial<TData>, TVariables>;\n\n/**\n * A hook for imperatively loading a query, such as responding to a user\n * interaction.\n *\n * > Refer to the [Suspense - Fetching in response to user interaction](https://www.apollographql.com/docs/react/data/suspense#fetching-in-response-to-user-interaction) section for a more in-depth overview of `useLoadableQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLoadableQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function App() {\n *   const [loadGreeting, queryRef] = useLoadableQuery(GET_GREETING);\n *\n *   return (\n *     <>\n *       <button onClick={() => loadGreeting({ language: \"english\" })}>\n *         Load greeting\n *       </button>\n *       <Suspense fallback={<div>Loading...</div>}>\n *         {queryRef && <Hello queryRef={queryRef} />}\n *       </Suspense>\n *     </>\n *   );\n * }\n *\n * function Hello({ queryRef }) {\n *   const { data } = useReadQuery(queryRef);\n *\n *   return <div>{data.greeting.message}</div>;\n * }\n * ```\n *\n * @since 3.9.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns A tuple in the form of `[loadQuery, queryRef, handlers]`\n */\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LoadableQueryHookOptions\n): UseLoadableQueryResult<TData, TVariables>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions = Object.create(null)\n): UseLoadableQueryResult<TData, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { queryKey = [] } = options;\n\n  const [queryRef, setQueryRef] = React.useState<QueryRef<\n    TData,\n    TVariables\n  > | null>(null);\n\n  assertWrappedQueryRef(queryRef);\n\n  const internalQueryRef = queryRef && unwrapQueryRef(queryRef);\n\n  if (queryRef && internalQueryRef?.didChangeOptions(watchQueryOptions)) {\n    const promise = internalQueryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(queryRef, promise);\n  }\n\n  const calledDuringRender = useRenderGuard();\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      if (!internalQueryRef) {\n        throw new Error(\n          \"The query has not been loaded. Please load the query.\"\n        );\n      }\n\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<TVariables, TData>\n      );\n\n      setQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      if (!internalQueryRef) {\n        throw new Error(\n          \"The query has not been loaded. Please load the query.\"\n        );\n      }\n\n      const promise = internalQueryRef.refetch(options);\n\n      setQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const loadQuery: LoadQueryFunction<TVariables> = React.useCallback(\n    (...args) => {\n      invariant(\n        !calledDuringRender(),\n        \"useLoadableQuery: 'loadQuery' should not be called during render. To start a query during render, use the 'useBackgroundQuery' hook.\"\n      );\n\n      const [variables] = args;\n\n      const cacheKey: CacheKey = [\n        query,\n        canonicalStringify(variables),\n        ...([] as any[]).concat(queryKey),\n      ];\n\n      const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n        client.watchQuery({\n          ...watchQueryOptions,\n          variables,\n        } as WatchQueryOptions<any, any>)\n      );\n\n      setQueryRef(wrapQueryRef(queryRef));\n    },\n    [\n      query,\n      queryKey,\n      suspenseCache,\n      watchQueryOptions,\n      calledDuringRender,\n      client,\n    ]\n  );\n\n  const subscribeToMore: SubscribeToMoreFunction<TData, TVariables> =\n    React.useCallback(\n      (options) => {\n        invariant(\n          internalQueryRef,\n          \"The query has not been loaded. Please load the query.\"\n        );\n\n        return internalQueryRef.observable.subscribeToMore(options);\n      },\n      [internalQueryRef]\n    );\n\n  const reset: ResetFunction = React.useCallback(() => {\n    setQueryRef(null);\n  }, []);\n\n  return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];\n}\n", "import * as React from \"rehackt\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryRef } from \"../internal/index.js\";\nimport type { OperationVariables } from \"../../core/types.js\";\nimport type {\n  RefetchFunction,\n  FetchMoreFunction,\n  SubscribeToMoreFunction,\n} from \"./useSuspenseQuery.js\";\nimport type { FetchMoreQueryOptions } from \"../../core/watchQueryOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\n\nexport interface UseQueryRefHandlersResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  const unwrapped = unwrapQueryRef(queryRef);\n\n  return wrapHook(\n    \"useQueryRefHandlers\",\n    _useQueryRefHandlers,\n    unwrapped ?\n      unwrapped[\"observable\"]\n      // in the case of a \"transported\" queryRef object, we need to use the\n      // client that's available to us at the current position in the React tree\n      // that ApolloClient will then have the job to recreate a real queryRef from\n      // the transported object\n      // This is just a context read - it's fine to do this conditionally.\n      // This hook wrapper also shouldn't be optimized by React Compiler.\n      // eslint-disable-next-line react-compiler/react-compiler\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n    : useApolloClient()\n  )(queryRef);\n}\n\nfunction _useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  assertWrappedQueryRef(queryRef);\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return {\n    refetch,\n    fetchMore,\n    subscribeToMore: internalQueryRef.observable.subscribeToMore,\n  };\n}\n", "import * as React from \"rehackt\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryRef } from \"../internal/index.js\";\nimport { __use, wrapHook } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { ApolloError } from \"../../errors/index.js\";\nimport type { NetworkStatus } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport interface UseReadQueryResult<TData = unknown> {\n  /**\n   * An object containing the result of your GraphQL query after it completes.\n   *\n   * This value might be `undefined` if a query results in one or more errors\n   * (depending on the query's `errorPolicy`).\n   */\n  data: TData;\n  /**\n   * If the query produces one or more errors, this object contains either an\n   * array of `graphQLErrors` or a single `networkError`. Otherwise, this value\n   * is `undefined`.\n   *\n   * This property can be ignored when using the default `errorPolicy` or an\n   * `errorPolicy` of `none`. The hook will throw the error instead of setting\n   * this property.\n   */\n  error: ApolloError | undefined;\n  /**\n   * A number indicating the current network state of the query's associated\n   * request. {@link https://github.com/apollographql/apollo-client/blob/d96f4578f89b933c281bb775a39503f6cdb59ee8/src/core/networkStatus.ts#L4 | See possible values}.\n   */\n  networkStatus: NetworkStatus;\n}\n\nexport function useReadQuery<TData>(\n  queryRef: QueryRef<TData>\n): UseReadQueryResult<TData> {\n  const unwrapped = unwrapQueryRef(queryRef);\n\n  return wrapHook(\n    \"useReadQuery\",\n    _useReadQuery,\n    unwrapped ?\n      unwrapped[\"observable\"]\n      // in the case of a \"transported\" queryRef object, we need to use the\n      // client that's available to us at the current position in the React tree\n      // that ApolloClient will then have the job to recreate a real queryRef from\n      // the transported object\n      // This is just a context read - it's fine to do this conditionally.\n      // This hook wrapper also shouldn't be optimized by React Compiler.\n      // eslint-disable-next-line react-compiler/react-compiler\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n    : useApolloClient()\n  )(queryRef);\n}\n\nfunction _useReadQuery<TData>(\n  queryRef: QueryRef<TData>\n): UseReadQueryResult<TData> {\n  assertWrappedQueryRef(queryRef);\n  const internalQueryRef = React.useMemo(\n    () => unwrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  const getPromise = React.useCallback(\n    () => getWrappedPromise(queryRef),\n    [queryRef]\n  );\n\n  if (internalQueryRef.disposed) {\n    internalQueryRef.reinitialize();\n    updateWrappedQueryRef(queryRef, internalQueryRef.promise);\n  }\n\n  React.useEffect(() => internalQueryRef.retain(), [internalQueryRef]);\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          updateWrappedQueryRef(queryRef, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef, queryRef]\n    ),\n    getPromise,\n    getPromise\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n", "import type {\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport type {\n  DeepPartial,\n  OnlyRequiredProperties,\n} from \"../../utilities/index.js\";\nimport { InternalQueryReference, wrapQueryRef } from \"../internal/index.js\";\nimport type { PreloadedQueryRef } from \"../internal/index.js\";\nimport type { NoInfer } from \"../index.js\";\nimport { wrapHook } from \"../hooks/internal/index.js\";\n\ntype VariablesOption<TVariables extends OperationVariables> =\n  [TVariables] extends [never] ?\n    {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n      variables?: Record<string, never>;\n    }\n  : {} extends OnlyRequiredProperties<TVariables> ?\n    {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n      variables?: TVariables;\n    }\n  : {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n      variables: TVariables;\n    };\n\nexport type PreloadQueryFetchPolicy = Extract<\n  WatchQueryFetchPolicy,\n  \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n>;\n\nexport type PreloadQueryOptions<\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#canonizeResults:member} */\n  canonizeResults?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n  context?: DefaultContext;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n  errorPolicy?: ErrorPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n  fetchPolicy?: PreloadQueryFetchPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n  returnPartialData?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n  refetchWritePolicy?: RefetchWritePolicy;\n} & VariablesOption<TVariables>;\n\ntype PreloadQueryOptionsArg<\n  TVariables extends OperationVariables,\n  TOptions = unknown,\n> = [TVariables] extends [never] ?\n  [options?: PreloadQueryOptions<never> & TOptions]\n: {} extends OnlyRequiredProperties<TVariables> ?\n  [\n    options?: PreloadQueryOptions<NoInfer<TVariables>> &\n      Omit<TOptions, \"variables\">,\n  ]\n: [\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      Omit<TOptions, \"variables\">,\n  ];\n\n/**\n * A function that will begin loading a query when called. It's result can be\n * read by `useReadQuery` which will suspend until the query is loaded.\n * This is useful when you want to start loading a query as early as possible\n * outside of a React component.\n *\n * @example\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * const queryRef = preloadQuery(query, { variables, ...otherOptions });\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<div>Loading</div>}>\n *       <MyQuery />\n *     </Suspense>\n *   );\n * }\n *\n * function MyQuery() {\n *   const { data } = useReadQuery(queryRef);\n *\n *   // do something with `data`\n * }\n * ```\n */\nexport interface PreloadQueryFunction {\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <\n    TData,\n    TVariables extends OperationVariables,\n    TOptions extends Omit<PreloadQueryOptions, \"variables\">,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: PreloadQueryOptionsArg<NoInfer<TVariables>, TOptions>\n  ): PreloadedQueryRef<\n    TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n      TOptions[\"returnPartialData\"] extends true ?\n        DeepPartial<TData> | undefined\n      : TData | undefined\n    : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n    : TData,\n    TVariables\n  >;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<DeepPartial<TData> | undefined, TVariables>;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<TData | undefined, TVariables>;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n    }\n  ): PreloadedQueryRef<DeepPartial<TData>, TVariables>;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: PreloadQueryOptionsArg<NoInfer<TVariables>>\n  ): PreloadedQueryRef<TData, TVariables>;\n}\n\n/**\n * A higher order function that returns a `preloadQuery` function which\n * can be used to begin loading a query with the given `client`. This is useful\n * when you want to start loading a query as early as possible outside of a\n * React component.\n *\n * > Refer to the [Suspense - Initiating queries outside React](https://www.apollographql.com/docs/react/data/suspense#initiating-queries-outside-react) section for a more in-depth overview.\n *\n * @param client - The `ApolloClient` instance that will be used to load queries\n * from the returned `preloadQuery` function.\n * @returns The `preloadQuery` function.\n *\n * @example\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * ```\n * @since 3.9.0\n */\nexport function createQueryPreloader(\n  client: ApolloClient<any>\n): PreloadQueryFunction {\n  return wrapHook(\n    \"createQueryPreloader\",\n    _createQueryPreloader,\n    client\n  )(client);\n}\n\nconst _createQueryPreloader: typeof createQueryPreloader = (client) => {\n  return function preloadQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      VariablesOption<TVariables> = Object.create(null)\n  ): PreloadedQueryRef<TData, TVariables> {\n    const queryRef = new InternalQueryReference(\n      client.watchQuery({\n        ...options,\n        query,\n      } as WatchQueryOptions<any, any>),\n      {\n        autoDisposeTimeoutMs:\n          client.defaultOptions.react?.suspense?.autoDisposeTimeoutMs,\n      }\n    );\n\n    return wrapQueryRef(queryRef) as PreloadedQueryRef<TData, TVariables>;\n  };\n};\n"],
  "mappings": "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",
  "names": ["operationName", "print", "_a", "version", "_b", "_c", "parseError", "HttpLink", "LocalState", "cache", "execute", "_a", "node", "ApolloClient", "cache", "defaultOptions", "result", "React", "React", "React", "React", "React", "React", "React", "DocumentType", "React", "React", "React", "React", "realHook", "__use", "hasOwnProperty", "noop", "internalState", "_a", "defaultOptions", "eagerMethods", "key", "execute", "options", "React", "setResult", "execute", "_a", "options", "mutation", "client", "React", "variables", "client", "subscription", "_a", "React", "React", "cache", "from", "React", "InternalQueryReference", "SuspenseCache", "promise", "toApolloError", "options", "variables", "_a", "React", "options", "promise", "variables", "React", "options", "promise", "queryRef", "React", "React", "promise", "toApolloError"]
}
